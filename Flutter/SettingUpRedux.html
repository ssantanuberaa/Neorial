<!DOCTYPE html>
<html>
<head>
	<title>Setting Up Redux in Flutter</title>
	<link rel="stylesheet" type="text/css" href="../Assets/bulma.css">
	<link rel="stylesheet" type="text/css" href="../Assets/Style.css">
	<script type="text/javascript" src="../Assets/prism.min.js"></script>
	<script type="text/javascript" src="../Assets/jquery.min.js"></script>
  <link rel="stylesheet" href="../Assets/prism-dark.css">
</head>
<body class="Body">
<div class="Content Card">




<h1>Setting Up Redux in Flutter</h1>
<p>Redux is an architecture with a unidirectional data flow that makes it easy to develop applications that are easy to test and maintain.</p>
<img src="Assets/redux-architecture-overview.png">
<p>In Redux there's a <code>Store</code> which holds a <code>State</code> object that represents the state of the whole application. Every application event (either from the user or external) is represented as an <code>Action</code> that gets dispatched to a <code>Reducer</code> function. This <code>Reducer</code> updates the <code>Store</code> with a new <code>State</code> depending on what <code>Action</code> it receives.</p>
<p>And whenever a new <code>State</code> is pushed through the <code>Store</code> the <code>View</code> is recreated to reflect the changes.</p>
<p>With Redux most components are decoupled, making UI changes very easy to make. In addition, the only business logic sits in the <code>Reducer</code> functions. A <code>Reducer</code> is a function that takes an <code>Action</code> and the current application <code>State</code> and it returns a new <code>State</code> object.</p>






<h1>Redux Middleware</h1>
<p>The above at first glance appears to be straightforward, but what happens when the application has to perform some asynchronous operation, such as loading data from an external API? This is why people came up with a new component known as the <code>Middleware</code>.</p>
<p><code>Middleware</code> is a component that may process an <code>Action</code> before it reaches the <code>Reducer</code>. It receives the current application <code>State</code> and the <code>Action</code> that got dispatched, and it can run some code (usually a side effect), such as communicating with a 3rd-party API or data source. Finally, the Middleware may decide to dispatch the original <code>Action</code>, to dispatch a different one, or to do nothing more.</p>
<p>With the <code>Middleware</code>, the above diagram would look like this:</p>
<img src="Assets/redux-architecture-overview-middleware.png">



<h1>Redux in Flutter</h1>
<p>Taking all this to Flutter, there's two very useful packages we can use, making it really easy and convenient to implement Redux in a Flutter app:</p>
<ul>
	<li><code>redux</code> : The <code>redux</code> package adds all the necessary components to use Redux in Dart, that is, the <code>Store</code>, the <code>Reducer</code> and the <code>Middleware</code>.</li>
	<li><code>flutter_redux</code> : This is a Flutter-specific package which provides additional components on top of the <code>redux</code> library which are useful for implementing Redux in Flutter, such as: <code>StoreProvider</code> (the base Widget for the app that will be used to provide the <code>Store</code> to all the Widgets that need it), <code>StoreBuilder</code> (a Widget that receives the <code>Store</code> from the <code>StoreProvider</code>) and <code>StoreConnector</code> (a very useful Widget that can be used instead of the <code>StoreBuilder</code> as you can convert the <code>Store</code> into a <code>ViewModel</code> to build the Widget tree and whenever the <code>State</code> in the <code>Store</code> is modified, the <code>StoreConnector</code> will get rebuilt).
</li>
</ul>






<h1>Code</h1>
<p>I’ve created a basic to-do list app to demonstrate the concepts discussed above. Let’s go through the important parts.</p>
<p>First, the <code>main.dart</code> file (which is our app’s entry point) defines the application <code>Store</code> object from an initial <code>State</code>, a <code>Reducer</code> function and the <code>Middleware</code>. It then it wraps the <code>MaterialApp</code> object with a <code>StoreProvider</code> that takes the <code>Store</code> and can pass it to its descendant Widgets that need one:</p>
<pre>
void main() => runApp(ToDoListApp());

class ToDoListApp extends StatelessWidget {
	final Store<AppState> store = Store<AppState>(
		appReducer, /* Function defined in the reducers file */
		initialState: AppState.initial(),
		middleware: createStoreMiddleware(),
	);

	@override
	Widget build(BuildContext context) => StoreProvider(
		store: this.store,
		child: MaterialApp(
			// Omitting some boilerplate here
			home: ToDoListPage(title: 'Flutter Demo Home Page'),
		),
	);
}
</pre>
<p>The followin <code>AppState</code> class contains the list of to-do items and a field to decide whether or not to display the <code>TextField</code> to add a new item:</p>
<pre>
class AppState {
	final List&lt;ToDoItem> toDos;
	final ListState listState;

	AppState(this.toDos, this.listState);

	factory AppState.initial() => AppState(List.unmodifiable([]), ListState.listOnly);
}

enum ListState {
	listOnly, listWithNewItem
}
</pre>
<p>In order to display the to-do list, we define a <code>ViewModel</code> class that contains a view-specific representation of the data we need to display, as well as the actions the user can do. This <code>ViewModel</code> gets created from the <code>Store</code>:</p>
<pre>
class _ViewModel {
	final String pageTitle;
	final List<_ItemViewModel> items;
	final Function onNewItem;
	final String newItemToolTip;

	_ViewModel(this.pageTitle, this.items, this.onNewItem, this.newItemToolTip, this.newItemIcon);

	factory _ViewModel.create(Store<AppState> store) {
		List<_ItemViewModel> items = store.state.toDos
		.map((ToDoItem item) => /* Omitting some boilerplate here */)
		.toList();

    	return _ViewModel('To Do', items, () => store.dispatch(DisplayListWithNewItemAction()), 'Add new to-do item', Icons.add);
	}
}
</pre>
<p>Now we can use the <code>ViewModel</code> class to display the to-do list. Notice that we wrap our Widgets inside a <code>StoreConnector</code> which allows us to create the <code>ViewModel</code> from the <code>Store</code> and build our UI using the <code>ViewModel</code>:</p>
<pre>
class ToDoListPage extends StatelessWidget {
	@override
	Widget build(BuildContext context) => StoreConnector<AppState, _ViewModel>(
		converter: (Store<AppState> store) => _ViewModel.create(store),
		builder: (BuildContext context, _ViewModel viewModel) => Scaffold(
			appBar: AppBar(
				title: Text(viewModel.pageTitle),
			),
			body: ListView(
				children: viewModel.items.map((_ItemViewModel item) => _createWidget(item)).toList()
			),
			floatingActionButton: FloatingActionButton(
				onPressed: viewModel.onNewItem,
				tooltip: viewModel.newItemToolTip,
				child: Icon(viewModel.newItemIcon),
			),
		),
	);
}
</pre>














</div>
</body>
</html>